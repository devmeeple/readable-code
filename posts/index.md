## Early return

> else 사용을 '지양'하자. switch도 유사하다. 사용하지 말자가 아니다.

```typescript
if (password.length >= 8) {
  doSomeThing1();
} else if (password <= 3 && user === 'ADMIN') {
  doSomeThing2();
} else {
  doSomeThing3();
}
```

> 비밀번호는 8자가 넘어야해. 넘으면 일해. 아 참, 그런데 3글자가 넘지 않고 사용자가 관리자면 다른 일해. 또는 이거해.

Early return을 적용하기 전 작성한 코드는 위와 같다. 모든 조건을 인지하고 있어야해서 이해하기 어렵다.
RAM은 한정적인데 과하게 사용한다. 그렇다면 오늘의 주인공 Early return을 적용한 구조는 어떨까.

```typescript
if (password.length >= 8) {
  doSomeThing1();
  return;
}

if (password <= 3 && user === 'ADMIN') {
  doSomeThing2();
  return;
}
doSomeThing3();
```

글쓰기를 좋아한다. 글을 작성할 때는 일단 쓰고 필요없는 단어를 지우며 퇴고한다. 프로그래밍 언어에 상관없이 개발의 조건을 작성할 때 `if...else`는 한번 쯤 배우고 넘어간다.
`return` 키워드를 추가해서 분리한다. 다음은 즐겨보는 mdn web docs에서 소개하는 예제를 각색했다.

```typescript
function isPositive(num: number) {
  if (num > 0) {
    return true;
  } else {
    return false;
  }
}
```

처음 개발을 배울때 작성하는 익숙한 코드다. 함수 isPositive는 입력받은 num 변수가 양수인지, 음수인지 확인하는 함수다. 작성한 코드를 한국어로 풀어쓰면 다음과 같다.
매개변수 num을 가지는 isPositive를 선언한다. num이 0보다 크면 POSITIVE(양수)를 반환하고 또는 NOT POSITIVE를 반환한다.
간단한 프로그램이어서 무난하게 읽힌다고 생각할 수 있다. 그런데 내가 원하는 문장이 아니다. 퇴고를 진행해보자.

```typescript
function isPositive(num: number) {
  if (num < 0) {
    return false;
  }

  return true;
}
```

같은 동작을 하는 코드를 수정했다. 수정한 함수는 다음과 같이 읽힌다.

> 매개변수 num을 가지는 isPositive를 선언한다. (동일) num이 0보다 작으면 false 를 반환한다. true를 반환한다.

크게 2가지를 수정했다. 로직의 순서와 또는과 같은 접속사를 버렸다. 내 생각에 isPositive를 읽는 사람은 이름을 보고 양수인지 확인하는 프로그램이라고 생각할 것 같다.
이 때 중요한건 '양수가 아닌 케이스를 어떻게 처리할지 여부'라고 생각했다. 그래서 예외처리 하는 부분을 위로 올렸다.

이전 코드는 '조건을 만족하면 true 반환하고 만족하지 않으면 false를 반환한다'는 식으로 작성했다.
하지만, Early return을 사용해서 '조건이 아니면 false를 반환한다'라는 예외케이스를 우선 배치했다.
그리고 위와 같은 조건은 `else`가 없어도 큰 문제가 없다고 생각한다. 오히려 필요없는 단어를 사용해서 지웠다.

**<참고 자료>**

- [『프로그래머의 뇌』(펠리너 헤르만스, 제이펍, 2022)](https://product.kyobobook.co.kr/detail/S000001952236)
- [『리팩터링』(마틴 파울러, 한빛미디어, 2020)](https://product.kyobobook.co.kr/detail/S000001810241)

## 사고의 depth 줄이기

- 중첩 분기문, 중첩 반복문
- 사용할 변수는 가깝게 선언하기

'무조건 1 depth로 만들어라'가 아니다. 사고를 하는 RAM의 비용을 줄이자. 만약 중첩 구조가 사고에 도움이 된다면 그대로 두자. 중요한 점은 자연스러운 사고다.

### 중첩 분기문, 중첩 반복문

```java
private static boolean isAllCellOpened2() {
    return Arrays.stream(BOARD)// Stream<String[]>
            .flatMap(Arrays::stream) // Stream<String>
            .noneMatch(cell -> cell.equals(CLOSED_CELL_SIGN));
}
```

Stream을 사용한다. 만약 Stream 같은 문법이 읽기 어렵다면 '로직을 나눠고 변수를 추출'하는 방법을 추천한다.

### 사용할 변수는 가깝게 선언하기

> 원숭이 엉덩이는 빨개<br>
> 빨가면 사과<br>
> 바나나는 길어<br>
> 길으면 기차<br>
> 기차는 빨라<br>
> 빠르면 비행기<br>
> 비행기는 높아<br>
> 높으면 백두산<br>
> 아 맞다 사과는 맛있어 (?)

설명하는 문장을 떨어트리지 말고 이어서 작성한다.

## 공백 라인을 대하는 자세

> 복잡한 라인을 나눔으로 읽는 사람에게 추가 정보를 제공한다.

글의 문단을 나누는 행동과 같다. 첫번째 문단에는 주장을, 두번째 문단에는 설명을, 마지막 문단에는 최종 입장을 밝힌다. 사람마다 기준이 다르다.
중요한 점은 '코드를 작성한 사람'이 생각할 때 관련있는 문장끼리 모아서 문단을 나눠야 한다. 문단을 나누지 않고, 문장도 한 문장으로 길게쓴 글을 읽어본 적 있을 것이다.
공백을 둠으로 읽는 사람에게 숨 쉴 자리를 마련하자.

## 부정어를 대하는 자세

- 부정어구를 사용하지 않아도 되는 상황인가
- 부정의 의미를 담은 다른 단어가 존재하는가, 부정어구로 메서드명 구성

```typescript
if (!isLeftDirection()) {
  doSomeThing();
}
```

> 가장 궁금했던 부분이다. 메서드를 이해하고 부정을 해야 한다는 점이 부자연스럽다고 생각했다. 중요한 점은 사고의 전환이다.

```typescript
if (isRightDirection()) {
  doSomeThing();
}

if (isNotLeftDirection()) {
  doSomeThing();
}
```

부정 연산자 대신에 할 수 있는 사고전환을 소개한다.
예를 들어 다른 방향이 있으면 `isRightDirection`을 사용한다. 또는 부정 연산자 대신 `isNotLeftDirection`을 사용한다.

## 해피 케이스와 예외 처리

- 해피 케이스: 의도대로 동작한다.
- 예외 처리: 예상하지 못한 상황

사람은 주로 해피 케이스에 몰두한다. (정상작동하면 얼마나 좋을까) 하지만 예외 처리에 신경써야 견고한 프로그램을 만들 수 있다.
그렇다면 예외 처리를 잘하기 위해서는 어떤 노력이 필요할까.

- 예외가 발생할 가능성 낮추기
- 검증(validation)이 필요한 부분은 주로 외부 세계와의 접점이다: 사용자 입력, 생성자, 외부 서버의 요청 등
- 의도한 예외와 예상하지 못한 예외를 구분하기: 사용자에게 보여주는 에러, 개발자가 보고 처리해야 할 에러를 구분한다.

> 김영한님 예외 처리 이야기가 떠오른다.

### Null을 대하는 자세

- NullPointException을 방지하는 방향으로 경각심을 가진다.
- 메서드 설계 시 return null을 자제한다: 불가피한 상황에선 Optional을 고려한다.
- Optional에 관하여
    - Optional은 비싼 객체다. 꼭 필요한 상황에서 반환 타입에 사용한다.
    - Optional을 파라미터로 받지 않도록 한다. 분기 케이스가 3개가 만들어진다. (Optional을 가진 데이터가 null인가, 아닌가 + Optional 자체가 null)
    - Optional을 받았다면 최대한 빠르게 해소한다.
        - Optional을 어떻게 해소하는 방법
            - 분기문을 만드는 isPresent() - get() 대신 풍부한 API 사용(예: orElseGet(), orElseThrow(), ifPresent(), ifPresentOrElse())
            - orElse(), orElseGet(), orElseThrow() 차이 숙지하기 *: 성능상 문제가 발생할 수 있다.
            - orElse() = 항상 실행, 확정된 값일 때 사용, orElseGet() = null인 경우 실행, 값을 제공하는 동작(supplier) 정의

> Optional은 섹션 6 예제에서 추가 설명한다. TypeScript에서는 어떤 생각을 하고 코드를 쨔면 좋을지 생각이 필요하다.

## 키워드 정리

- 뇌 메모리 적게 쓰기(인지 경제성)
- Early return, 사고의 depth 줄이기(메서드 분리)
- 공백 라인, 부정어
- 해피 케이스, 예외 처리
- stream API, Optional

> 잘 쓰인 코드란 읽는 사람의 편의를 고려해 작성한 코드다. '가독성'에 대해 주로 이야기하는데 가독성이란 사람마다 기준이 다르다.
> 하지만 전하고 싶은 이야기는 작성한 코드를 말로 바꿔서 표현할 때 자연스러운 것이 가독성이 좋은 읽기 쉬운 코드라고 생각한다.

## 3.1 추상의 관점으로 바라보는 객체 지향

- 절차 지향: 컴퓨터가 동작하는 방식처럼 코드를 작성한다.
- 객체 지향: 객체를 선언하고 객체 간의 협력을 중점으로 코드를 작성한다.
- 함수형: 순수 함수 기반으로 코드를 작성한다.
- 객체 간의 협력과 객체가 담당하는 책임은 무엇인가.
- 관심사의 분리(Separation Of Concern), 높은 응집도, 낮은 결합도
    - A와 B 객체가 관계를 가진다. A를 수정하면 B가 영향을 받는 정도가 적어야 '결합도가 낮다'라고 표현한다. 최소한의 변화를 지향한다.

> 강의에 오탈자가 있다. 관심사의 분리(Seperation Of Concern -> Separation Of Concern)

## 3.2 객체 설계하기 (1)

- 비공개 필드(데이터), 비공개 로직(코드)
- 공개 메서드 선언부를 통해 외부 세계와 소통
    - 각 메서드의 기능은 객체를 책임을 드러내는 창구
- 객체의 책임이 나뉨에 따라 객체 간 협력이 발생

### 객체가 제공하는 것

- 절차 지향에서 잘 보이지 않던 개념을 가시화
- 관심사가 한 군데로 모이기 때문에, 유지보수성 ⬆️
    - 객체 내부에서 객체가 가진 데이터의 유효성 검증 책임을 가질 수 있다.
- 객체를 사용하는 입장에서는, 구체적인 구현에 신경 쓰지 않고 보다 높은 추상화 레벨에서 도메인 로직을 다룰 수 있다.

### 새로운 객체를 만들 때 주의할 점

- 1개의 관심사로 명확하게 책임이 정의되었는지 확인하기
    - 메서드를 추상화할 때와 비슷하다.
    - 객체를 만듦으로써 외부 세계와 어떤 소통을 시도하는지 있는지 생각하자.

```typescript
class Money {
  private value: number;

  constructor(value: number) {
    if (value < 0) {
      throw new Error('돈은 0원 이상이어야 합니다.');
    }
    this.value = value;
  }
}
```

- 생성자, 정적 팩토리 메서드에서 유효성 검증이 가능하다.
    - 도메인에 특화된 검증 로직이 들어갈 수 있다.
- setter 사용 자제
    - 데이터는 불변이 최고다. 변하는 데이터라도 객체가 핸들링할 수 있어야 한다.
    - 객체 내부에서 외부 세계의 개입 없이 자체적인 변경/가공으로 처리할 수 있는지 확인한다.
    - 만약 외부에서 가지고 있는 데이터로 데이터 변경을 요청해야 하는 경우, 'set~'이라는 단순한 이름보다는 'update~' 같이 의도를 드러내는 네이밍을 고려하자.

> 가급적이면 데이터가 불변이어야 하는 이유는 부수 효과(side effect)를 덜어준다. 디버깅 시간을 줄여준다.
> 이야기하고 싶은 내용은 '객체 생성과 동시에 setter를 선언하는 행동을 멈추자'다. 최후의 보루로 남겨두자.

- getter도 처음에는 사용 자제한다. 반드시 필요한 경우에 추가한다.
    - 외부에서 객체 내 데이터가 필요하다고 getter를 남발하는 것은 무례한 행동이다.
    - 객체에 메시지를 보내자!

> getter 또한 마찬가지다. 객체 생성과 동시에 getter, setter를 선언하는 것이 아닌 필요한 순간에 추가하자.
> 객체가 객체답게(?) 살 수 있도록 환경을 마련하자. "데이터 가져와!"가 아니라 "데이터 있어?" 물어보자.

- 필드의 수는 적을수록 좋다.
    - 불필요한 데이터가 많을수록 복잡도가 높아지고 대응할 변화도 많아진다.
    - 필드 A를 계산할 수 있는 또 다른 필드가 있다면, 메서드 기능으로 제공한다.
    - 단, 미리 가공하는 것이 성능상 이점이 있다면 필드로 가지고 있는 점이 좋을 수도 있다.

## 3.3 객체 설계하기 (2)

```java
// 캡슐화되어 있는 데이터 가져와.
private static boolean isAllCellOpened() {
    return Arrays.stream(BOARD)
            .flatMap(Arrays::stream)
            .noneMatch(cell -> cell.getSign().equals(CLOSED_CELL_SIGN));
}

// 데이터 가지고 있습니까? 물어보기
private static boolean isAllCellOpened() {
    return Array.stream(BOARD)
            .flatMap(Array::stream)
            .noneMatch(cell -> cell.equalsSign(CLOSED_CELL_SIGN));
}
```

직접 객체를 생성하고 캡슐화시켰기 때문에 이미 데이터를 알고 있다. 하지만 다른 객체(외부 세계) 입장에서는 데이터를 모른다.
따라서 객체 지향 사고를 위해서는 데이터를 물어보자. 공개 메서드로 외부 세계와 소통한다.

> 아직 getter를 사용해야 할 상황과 메시지를 던지는 상황이 쉽게 그려지진 않는다.
> 급하게 다가가려고 하지 말고 이런 고민을 하며 객체를 설계하다 보면 자연스럽게 다가갈 수 있지 않을까 하는 기대를 품는다.

> 💡 IntelliJ Multiple cursors: `⌥Opt` 두 번 누르고 위아래

> 처음에 이 챕터의 시간이 왜 이렇게 길지? 이어서 들으라고 강조하시는 이유가 무엇일까. 의아했다. 그런데 이유를 알았다.
> 코드의 결과만 제공하는 게 아니라 '이런 방법으로 사고한다' 사유하는 방법을 알려주는 챕터다.

### 도메인 지식을 얻었다!

- '열렸다/닫혔다'는 개념과, '사용자가 체크했다' 개념은 다르다.
    - ex) 깃발: 닫혀있지만 체크했으면 게임 종료 조건의 일부다.
- 기존은 sign(String) 기반의 보드(Board)였다. 하지만 표시할 sign을 바꾸는 형태에서 정보를 담는 '셀(Cell)'을 선언했다. 보드는 셀을 갈아 끼우는 방식이 아닌 사용자의 행동에 따라
  셀의 상태를 변화시키는 방향으로 코드를 리팩터링 한다.
    - 지뢰 여부와 주변 지뢰 개수는 별도의 공간이 있어서 가능했다.

도메인 지식은 만드는 것이 아니다. 발견하는 것이다.

> 도메인 지식을 발견한다는 것은 '다른 문제가 생겼다'를 의미한다. 그렇다면 '탐구'자체를 좋아하지 않으면 스트레스로 다가올 것 같다.

## 3.4 SOLID

> SOLID Robert C. Martin(a.k.a. Uncle Bob), 클린 코드, 클린 아키텍처

- SRP: Single Responsibility Principle
- OCP: Open-Closed Principle
- LSP: Liskov Substitution Principle
- ISP: Interface Segregation Principle
- DIP: Dependency Inversion Principle

원칙을 이론에서 벗어나 코드레벨에서 알아보자. 과연 실무에서 적용할 수 있을까.

## 3.5 단일 책임 원칙(SRP, Single Responsibility Principle)

> 객채가 하나의 책임만 가지도록 만들자.

- 하나의 클래스는 단 한 가지의 변경 이유를 가져야 한다.
    - '변경 이유' = 책임
- 객체가 가진 공개 메서드, 필드, 상수 등은 해당 객체의 단일 책임에 의해서만 변경되는가?
- 관심사의 분리
- 높은 응집도, 낮은 결합도

> 응집도란 '클래스나 모듈 내의 연관되어 있는 정도'를 의미한다. 결합도란 '협력을 맺는 객체가 변경되었을 때 다른 객체가 받는 영향의 정도(의존성)'를 의미한다.

## 3.6 개방-폐쇄 원칙(OCP, Open-Closed Principle)

- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다.
    - 기존 코드의 변경 없이, 시스템의 기능을 확장할 수 있어야 한다.
- 추상화와 다형성을 활용해서 OCP를 지킬 수 있다.

### 새로운 요구사항

- 게임의 난이도를 변경할 수 있어야 한다.
- 난이도
    - 매우 쉬움  : 가로 5, 세로 4, 지뢰 2
    - 초급      : 가로 10, 세로 8, 지뢰 10
    - 중급      : 가로 18, 세로 14, 지뢰 40
    - 고급      : 가로 24, 세로 20, 지뢰 99
